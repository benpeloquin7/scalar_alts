---
title: "Scalar alternatives analysis"
author: "Ben Peloquin & Mike Frank"
date: "July 22, 2016"
output:
  html_document:
    toc: true
    toc_depth: 4
---


```{r clean_session}
rm(list=ls())
```

Packages
```{r packages, warning=FALSE, message=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(rjson)
library(binom)
library(lme4)
library(lmerTest)
library(rrrsa)
source("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/scalar_alts_analysis_helpers.R")
```


Experimental set-up notes

Note: this is not a part of pre-registration analysis
```{r expt_setup}
## Literal listener trials
NUM_ITEMS <- 105
trials <- sample.int(n=NUM_ITEMS, size=NUM_ITEMS)

trial_meta <- function(n) {
  item <- n %% 21
  stars <- n %% 5
  c("item"=item, "stars"=stars)
}

d_trials <- data.frame(t(as.matrix(sapply(trials, trial_meta))))
d_trials <- d_trials %>%
  mutate(stars=stars + 1) %>%
  arrange(item)
```

# Stimuli
```{r global_helpers}
## global data
NUM_ITEMS <- 21 ## number of individual target scalars (some are shared)
DOMAINS <- c("album", "book", "game", "play", "movie", "restaurant")
## scales
bad_terrible <-            c("terrible", "bad", "okay", "good", "great")
liked_loved <-             c("hated", "disliked", "tolerated", "liked", "loved")
good_excellent <-          c("terrible", "bad", "average", "good", "excellent")
memorable_unforgettable <- c("forgettable", "boring", "ordinary", "memorable", "unforgettable")
special_unique <-          c("boring", "different", "common", "special", "unique")
all_scales <- data.frame("bad_terrible"=bad_terrible,
                         "liked_loved"=liked_loved,
                         "good_excellent"=good_excellent,
                         "memorable_unforgettable"=memorable_unforgettable,
                         "special_unique"=special_unique)

## valence
map_word_type <- function(word) {
  hi2 <- c("great", "loved", "excellent", "unforgettable", "unique")
  hi1 <- c("good", "liked", "memorable", "special")
  mid <- c("okay", "tolerated", "average", "ordinary", "common")
  low1 <- c("bad", "disliked", "bad", "forgettable", "different")
  low2 <- c("terrible", "hated", "terrible", "boring", "boring")
  
  if (word %in% hi2) "hi2"
  else if (word %in% hi1) "hi1"
  else if (word %in% mid) "mid"
  else if (word %in% low1) "low1"
  else if (word %in% low2) "low2"
  else "training"
}
```

# 1) Literal Listener (L0) analysis 

## Experimental set-up

Literal listener studies provide approximate literal semantic data for our target scalar items. 

We're testing 5 scales, each containing 5 items, across 6 domains (see `Stimuli` section above). Since some words are shared between scales we have 21 unique words. See `Stimuli` section above.

Data for domains is between subjects -- subjects only provide responses in the context of one domain at a time.

Data for individual words is within subjects -- subjects provide five ratings for each word (one judgment for each star rating 1-5 stars for a total of 5 * 21 = 105 responses for each participant).

Response is a binary `yes`/`no` response if the target word is compatible with the displayed star-rating.

<br>
<center>
  <br>
  <img src="/Users/benpeloquin/Desktop/Projects/scalar_alts/pre-registration/L0_design.png"
  width="500px" height="200px" style='border:1px solid #000000'>
  <br>
  <caption>Example trial from L0 Literal listener study.</caption>
  <br>
</center>
<br>

## Data pre-processing (combine domains, data-typing).
```{r L0_data_preprocessing, warning=FALSE, message=FALSE}
d_album_L0 <- create_domain_df("album", dir_path=create_dir_path("album", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_book_L0 <- create_domain_df("book", dir_path=create_dir_path("book", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_game_L0 <- create_domain_df("game", dir_path=create_dir_path("game", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_movie_L0 <- create_domain_df("movie", dir_path=create_dir_path("movie", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_play_L0 <- create_domain_df("play", dir_path=create_dir_path("play", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_restaurant_L0 <- create_domain_df("restaurant",
                                 dir_path=create_dir_path("restaurant", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)

d_agg_L0 <- rbind(d_album_L0, d_book_L0, d_game_L0, d_movie_L0, d_play_L0, d_restaurant_L0)
```

```{r L0_data_prep, warning=FALSE, message=FALSE}
## Literal semantics
d_agg_sems <- d_agg_L0 %>%
  group_by(domain, item, word_type, stars) %>%
  summarise(avg_judgment=mean(judgment),
            ci_low=binom.confint(sum(judgment), length(judgment))$lower[3],
            ci_high=binom.confint(sum(judgment), length(judgment))$upper[3]) %>%
  ungroup %>%
  mutate(domain=as.factor(domain))
```

## Primary analysis - domain level differences

### Plots by scalar pairs and domains

Plot non-normalized literal listener semantics, facet by word, color by domain.
```{r L0_domain_differences_plot}
ggplot(d_agg_sems, aes(x=stars, y=avg_judgment, col=domain)) +
  geom_line() +
  geom_errorbar(aes(ymax=ci_high, ymin=ci_low), width=0) +
  facet_wrap(~item)
```

Plot non-normalized literal listener semantics, facet by scale and word-valence, color by word.
```{r L0_domain_differences_plot2}
ggplot(d_agg_sems, aes(x=stars, y=avg_judgment, col=item)) +
  geom_line() +
  geom_errorbar(aes(ymax=ci_high, ymin=ci_low), width=0) +
  facet_grid(domain~word_type)
```

Doesn't look like there's much differentiation in literal semantics by domain.

### Does domain predict response?

Statistical test: Logistic regression

Is `domain` a sigificant predictor of response.

Null hypothesis is there are no differences between domain (i.e. domain should not significantly predict response after controlling for `target_word`).
```{r L0_domain_differences_test}

## L0 listener data for glmer and glm
d_agg_L0_test <- d_agg_L0 %>%
  mutate(worker_id=as.factor(worker_id),
         item=as.factor(item))

# knitr::kable(summary(glm(judgment~item+domain+word_type, family="binomial", data=d_agg_L0_test)))
summary(glmer(judgment~domain+word_type+(1|item)+(1|worker_id), family="binomial", data=d_agg_L0_test))
```

## Secondary analysis -- word level differences

### Plots by word and domains (line chart, facets by word, lines are literal semantics for each domain)
```{r L0_word_sensitivity_plot}
# ggplot()
```

### Statistical test

- Logistic regression on data subset for each word

H0: domain should not predict response.
```{r L0_word_sensitivity_test1}
# glm()
```

- Chi-square test of independence
```{r L0_word_sensitivity_test2}
# chisq.test()
```

# 2) Pragmatic Listener (L1) analysis 

## Experimental set-up

Pragmatic listener studies provide pragmatic interpretations for our target scalar items. 

We're testing 5 scales, each containing 5 items, across 6 domains (see `stimuli` section above). Since some words are shared between scales we have 21 unique words.

Data for domains is between subjects -- subjects only provide responses in the context of one domain at a time.

Data for individual words is within subjects -- subjects provide one rating for each word (providing 1 * 21 = 21 responses per particpant).

Response is a rating between 1-5 stars.

<br>
<center>
  <br>
  <img src="/Users/benpeloquin/Desktop/Projects/scalar_alts/pre-registration/L1_design.png"
  width="500px" height="200px" style='border:1px solid #000000'>
  <br>
  <caption>Example trial from L1 Pragmatic listener study.</caption>
  <br>
</center>
<br>


## Data pre-processing (combine domains, data-typing).
```{r L1_data_preprocessing, warning=FALSE, message=FALSE}
d_album_L1 <- create_domain_df("album", dir_path=create_dir_path("album", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_book_L1 <- create_domain_df("book", dir_path=create_dir_path("book", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_game_L1 <- create_domain_df("game", dir_path=create_dir_path("game", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_movie_L1 <- create_domain_df("movie", dir_path=create_dir_path("movie", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_play_L1 <- create_domain_df("play", dir_path=create_dir_path("play", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_restaurant_L1 <- create_domain_df("restaurant",
                                 dir_path=create_dir_path("restaurant", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)

d_agg_L1 <- rbind(d_album_L1, d_book_L1, d_game_L1, d_movie_L1, d_play_L1, d_restaurant_L1)
```

```{r L1_data_prep}
d_agg_prags <-  d_agg_L1 %>%
  group_by(domain, word_type, item, judgment) %>%
  summarise(counts=n())
```

## Primary analysis -- domain level differences

### Plots by scalar pairs and domains

```{r L1_domain_differences_plot}
ggplot(d_agg_prags, aes(x=judgment, y=counts, fill=domain)) +
    geom_bar(position="dodge", stat="identity") +
    facet_wrap(~item)
```

```{r}
ggplot(d_agg_prags, aes(x=judgment, y=counts, fill=item)) +
    geom_bar(position="dodge", stat="identity") +
    facet_grid(domain~word_type)
```


### Does domain predict response?

Statistical test: Multiple regression

Is `domain` a sigificant predictor of response.

Null hypothesis is there are no differences between domain (i.e. domain should not significantly predict response).
```{r L1_domain_differences_test}
summary(lmer(judgment~domain+word_type+(1|worker_id)+(1|item), data=d_agg_L1))
```

## Secondary analysis -- word level differences

### Plots by word and domains (line chart, facets by word, lines are pragmatic judgments for each domain)
```{r L1_word_sensitivity_plot}
# ggplot()
```

### Statistical tests

Null hypothesis is scalar word pragmatic judgment distributions should not differ by domain.

- Multiple regression on data subset

Domain should not predict response when controlling for `target_word`
```{r L1_word_sensitivity_test1}
# glm()
```

We don't expect to see any statistical differences.
```{r L1_word_sensitivity_test2}
# chisq.test()
```


# 3) RSA comparison with human judgments

```{r}
rsa_read_df <- function(d_L0, d_L1) {
  
  ## Normalize L0
  normalize_semantics <- function(d) {
    norm_vec(d$avg_judgment)
  }
  pattern <- "V([1-5])"
  d_L0_sems <- plyr::ddply(.data=d_L0, .variables=c("domain", "word_type", "item"), .fun=normalize_semantics) %>%
    gather(stars, sems, -c(domain, word_type, item)) %>%
    arrange(domain, item, stars, word_type) %>%
    rowwise %>%
    mutate(stars=as.numeric(gsub(pattern, "\\1", stars)))
  
  ## Combine L0 and L1 data
  d_agg_L0_merge <- d_L0_sems
  d_agg_L1_merge <- d_L1 %>%
    mutate(stars=judgment) %>%
    select(domain, word_type, item, stars, counts)

  ## Joined data (L1 not normalized)
  d_agg_join <- plyr::join(d_agg_L0_merge, d_agg_L1_merge, by=c("domain", "word_type", "item", "stars"))
  d_agg_join[is.na(d_agg_join)] <- 0
  
  ## Normalize L1
  normalize_pragmatics <- function(d) {
    norm_vec(d$counts)
  }
  pattern <- "V([1-5])"
  normed_prags <- plyr::ddply(.data=d_agg_join, .variables=c("domain", "word_type", "item"), .fun=normalize_pragmatics) %>%
    gather(key=stars, value=prags, c(V1, V2, V3, V4, V5)) %>%
    rowwise %>%
    mutate(stars=as.numeric(gsub(pattern, "\\1", stars))) %>%
    arrange(domain, item, stars)
  
  ## Combined normalized semantics and pragmatics df
  d_agg_final <- plyr::join(d_agg_join, normed_prags, by=c("domain", "word_type", "item", "stars"))
  
  ## Data in wide format
  sems_wide <- d_agg_final %>% select(domain, word_type, item, stars, sems) %>%
    spread(stars, sems)
  prags_wide <- d_agg_final %>% select(domain, word_type, item, stars, prags) %>%
    spread(stars, prags)
  
  ## Data holds for separate semantics and pragmatics
  sems_scales_df <- data.frame(domain=c(),
                            item=c(),
                            scale=c(),
                            "1"=c(),
                            "2"=c(),
                            "3"=c(),
                            "4"=c(),
                            "5"=c())
  prags_scales_df <- data.frame(domain=c(),
                            item=c(),
                            scale=c(),
                            "1"=c(),
                            "2"=c(),
                            "3"=c(),
                            "4"=c(),
                            "5"=c())
  ## Populate data holds
  for (domain in DOMAINS) {
    for (scale in names(all_scales)) {
      for (item in all_scales[[scale]]) {
        # print("item:")
        # print(item)
        # print("----------------------")
        curr_sems_row <- sems_wide[which(sems_wide$item==item & sems_wide$domain==domain),] %>%
          mutate(scale=scale)
        curr_prags_row <- prags_wide[which(prags_wide$item==item & prags_wide$domain==domain),] %>%
          mutate(scale=scale)
        sems_scales_df <- rbind(sems_scales_df, curr_sems_row)
        prags_scales_df <- rbind(prags_scales_df, curr_prags_row)
      }
    }
  }
  sems_scales_df <- sems_scales_df %>%
    arrange(domain, scale, word_type, item) %>%
    gather(stars, sems, -c(domain, scale, word_type, item))
  prags_scales_df <- prags_scales_df %>%
    arrange(domain, scale, word_type, item) %>%
    gather(stars, prags, -c(domain, scale, word_type, item))
  
  ## Quick check
  nrow(sems_scales_df) == nrow(prags_scales_df)
  
  sems_scales_df[1:10,]
  prags_scales_df[1:10,]
  
  d_rsa_df <- plyr::join(sems_scales_df, prags_scales_df)
  
  d_rsa_df
}

```


```{r create_model_dfs, warning=FALSE, message=FALSE}
## two-alts model
d_agg_sems_2alt <- d_agg_sems %>% filter(word_type == "hi1" | word_type == "hi2")
d_agg_prags_2alt <- d_agg_prags %>% filter(word_type == "hi1" | word_type == "hi2")
two_alt_m <- rsa_read_df(d_agg_sems_2alt, d_agg_prags_2alt)

## three-alts model
d_agg_sems_3alt <- d_agg_sems %>% filter(word_type == "hi1" | word_type == "hi2" | word_type == "low1")
d_agg_prags_3alt <- d_agg_prags %>% filter(word_type == "hi1" | word_type == "hi2" | word_type == "low1")
three_alt_m <- rsa_read_df(d_agg_sems_3alt, d_agg_prags_3alt)

## four-alts model
d_agg_sems_4alt <- d_agg_sems %>% filter(word_type=="hi1" | word_type=="hi2" | word_type=="low1" | word_type=="low2")
d_agg_prags_4alt <- d_agg_prags %>% filter(word_type=="hi1" | word_type=="hi2" | word_type=="low1" | word_type=="low2")
four_alt_m <- rsa_read_df(d_agg_sems_4alt, d_agg_prags_4alt)

## five-alts model
five_alt_m <- d_rsa_df <- rsa_read_df(d_agg_sems, d_agg_prags)
```


Normalize L0 semantics 
```{r}
# normalize_semantics <- function(d) {
#   norm_vec(d$avg_judgment)
# }
# pattern <- "V([1-5])"
# d_L0_sems <- plyr::ddply(.data=d_agg_sems, .variables=c("domain", "word_type", "item"), .fun=normalize_semantics) %>%
#   gather(stars, sems, -c(domain, word_type, item)) %>%
#   arrange(domain, item, stars, word_type) %>%
#   rowwise %>%
#   mutate(stars=as.numeric(gsub(pattern, "\\1", stars)))
```

Combine L0 and L1 data. Do this step prior to normalizing L1 because `join` implicitly creates missing rows (NA's) for pragmatic responses. That is, sometime there is no data (i.e. 'excellent' was never selected at 1-3 stars so we want to create rows there).
```{r}
# d_agg_L0_merge <- d_L0_sems
# d_agg_L1_merge <- d_agg_prags %>%
#   mutate(stars=judgment) %>%
#   select(domain, word_type, item, stars, counts)
# 
# d_agg_join <- plyr::join(d_agg_L0_merge, d_agg_L1_merge, by=c("domain", "word_type", "item", "stars"))
# d_agg_join[is.na(d_agg_join)] <- 0
```

Normalize L1 data 
```{r}
# normalize_pragmatics <- function(d) {
#   norm_vec(d$counts)
# }
# pattern <- "V([1-5])"
# normed_prags <- plyr::ddply(.data=d_agg_join, .variables=c("domain", "word_type", "item"), .fun=normalize_pragmatics) %>%
#   gather(key=stars, value=prags, c(V1, V2, V3, V4, V5)) %>%
#   rowwise %>%
#   mutate(stars=as.numeric(gsub(pattern, "\\1", stars))) %>%
#   arrange(domain, item, stars)
```

Final data set with normalized semantics and pragmatics - long form
```{r}
# d_agg_final <- plyr::join(d_agg_join, normed_prags, by=c("domain", "word_type", "item", "stars"))
```

Convert to scalar_alts data frame for running RSA
```{r}
## Data in wide format
# sems_wide <- d_agg_final %>% select(domain, word_type, item, stars, sems) %>%
#   spread(stars, sems)
# prags_wide <- d_agg_final %>% select(domain, word_type, item, stars, prags) %>%
#   spread(stars, prags)
# 
# ## Data holds for separate semantics and pragmatics
# sems_scales_df <- data.frame(domain=c(),
#                           item=c(),
#                           scale=c(),
#                           "1"=c(),
#                           "2"=c(),
#                           "3"=c(),
#                           "4"=c(),
#                           "5"=c())
# prags_scales_df <- data.frame(domain=c(),
#                           item=c(),
#                           scale=c(),
#                           "1"=c(),
#                           "2"=c(),
#                           "3"=c(),
#                           "4"=c(),
#                           "5"=c())
# ## Populate data holds
# for (domain in DOMAINS) {
#   for (scale in names(all_scales)) {
#     for (item in all_scales[[scale]]) {
#       # print("item:")
#       # print(item)
#       # print("----------------------")
#       curr_sems_row <- sems_wide[which(sems_wide$item==item & sems_wide$domain==domain),] %>%
#         mutate(scale=scale)
#       curr_prags_row <- prags_wide[which(prags_wide$item==item & prags_wide$domain==domain),] %>%
#         mutate(scale=scale)
#       sems_scales_df <- rbind(sems_scales_df, curr_sems_row)
#       prags_scales_df <- rbind(prags_scales_df, curr_prags_row)
#     }
#   }
# }
# sems_scales_df <- sems_scales_df %>%
#   arrange(domain, scale, word_type, item) %>%
#   gather(stars, sems, -c(domain, scale, word_type, item))
# prags_scales_df <- prags_scales_df %>%
#   arrange(domain, scale, word_type, item) %>%
#   gather(stars, prags, -c(domain, scale, word_type, item))
# 
# ## Quick check
# nrow(sems_scales_df) == nrow(prags_scales_df)
# 
# sems_scales_df[1:10,]
# prags_scales_df[1:10,]
# 
# d_rsa_df <- plyr::join(sems_scales_df, prags_scales_df)
```

```{r}
two_alt_m %>%
  ggplot(aes(x=stars, y=sems, col="sems")) +
    geom_line(group=1) +
    geom_line(aes(x=stars, y=prags, col="prags"), group=1) +
    facet_grid(scale~word_type+domain)
```

-- Using L0 literal semantics as input to RSA how well can we fit the L1 pragmatic listener judgments varying the alternative sets available to the model?

## Basic RSA

```{r models}
two_alt_preds <- plyr::ddply(two_alt_m,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")

three_alt_preds <- plyr::ddply(three_alt_m,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")

four_alt_preds <- plyr::ddply(four_alt_m,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")
cor(four_alt_preds$prags, four_alt_preds$preds)


five_alt_preds <- plyr::ddply(five_alt_m,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item",
            alpha=1)
```

What's happening with model runs
```{r}
## good_excellent + restaurant
five_alt_practice_sems <- five_alt_preds %>%
  filter(domain=="restaurant", scale=="good_excellent") %>%
  select(word_type, stars, sems) %>%
  spread(word_type, sems) %>%
  select(stars, low2, low1, mid, hi1, hi2)
row.names(five_alt_practice_sems) <- five_alt_practice_sems$stars
five_alt_practice_sems <- five_alt_practice_sems[, -1]

debug(rsa.reason)
rsa.reason(as.matrix(five_alt_practice_sems))
```


```{r}
model_preds_test <- function(model_preds, test=cor) {
  filtered_preds <- model_preds %>% filter(word_type=="hi1" | word_type=="hi2")
  test(filtered_preds$prags, filtered_preds$preds)
}
model_preds_test(five_alt_preds)

five_alt_preds %>%
  filter((word_type=="hi1" | word_type=="hi2")) %>%
  ggplot(aes(x=preds, y=prags, col=domain)) +
    geom_point(alpha=0.4)

str(two_alt_preds)

View(two_alt_preds)
```


-- `depth=1`, `alpha=1` 2-alt vs 3-alt vs 4-alt vs 5-alt models

-- Standard theory predicts that listeners need only consider entailment alternatives in order to generate the implicature (2-alt model)

-- Test: do we see better model fit (correlation) by adding more alternatives and tuning hyper-parameters?
```{r basic_rsa_test}

```

## 2-alt model
```{r}
d_L0_scales <- d_L0_scales %>% mutate(stars=as.character(stars)) 
d_L0_scales_2alt <- d_L0_scales %>%
  mutate(stars=as.character(stars)) %>%
  filter(word_type=="hi1" | word_type=="hi2")
two_alt_preds <- plyr::ddply(d_L0_scales_2alt,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")
View(two_alt_preds)
```

```{r}
two_alt_preds %>% View
two_alt_preds %>%
  ggplot(aes(x=stars, y=preds, fill=word_type)) +
    geom_bar(stat="identity", position="dodge") +
    facet_grid(domain~scale)

```

## 3-alt model
```{r}
d_L0_scales <- d_L0_scales %>% mutate(stars=as.character(stars)) 
d_L0_scales_3alt <- d_L0_scales %>%
  mutate(stars=as.character(stars)) %>%
  filter(word_type=="hi1" | word_type=="hi2" | word_type=="low1")
three_alt_preds <- plyr::ddply(d_L0_scales_3alt,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")
```

```{r}
three_alt_preds %>% View
three_alt_preds %>%
  ggplot(aes(x=stars, y=preds, fill=word_type)) +
    geom_bar(stat="identity", position="dodge") +
    facet_grid(domain~scale)
```

## 4-alt model
```{r}
d_L0_scales <- d_L0_scales %>% mutate(stars=as.character(stars)) 
d_L0_scales_4alt <- d_L0_scales %>%
  mutate(stars=as.character(stars)) %>%
  filter(word_type=="hi1" | word_type=="hi2" | word_type=="low1" | word_type=="low2")
four_alt_preds <- plyr::ddply(d_L0_scales_4alt,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")
```

```{r}
d_L0_scales_5alt <- d_L0_scales %>% mutate(stars=as.character(stars)) 
five_alt_preds <- plyr::ddply(d_L0_scales_5alt,
            .fun=rsa.runDf,
            .variables=c("domain", "scale"),
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item")
```


```{r}
two_alt_preds %>% View()
three_alt_preds %>% head(n=10)
four_alt_preds %>% head(n=10)
five_alt_preds %>% head(n=25)
```

```{r}
plyr::ddply(peloquinFrank_2Alts,
            .variables=c("scale"),
            .fun=rsa.runDf,
            quantityVarName="stars",
            semanticsVarName="speaker.p",
            itemVarName="words")
plyr::ddply(peloquinFrank_5Alts,
            .variables=c("scale"),
            .fun=rsa.runDf,
            quantityVarName="stars",
            semanticsVarName="speaker.p",
            itemVarName="words")

peloquinFrank_2Alts %>%
  filter(scale=="good_excellent") %>%
  spread(words, speaker.p)
```


## Tuned RSA

-- `depth=fit`, `alpha=fit` 2-alt vs 3-alt vs 4-alt vs 5-alt models

-- Standard theory predicts that listeners need only consider entailment alternatives in order to generate the implicature (2-alt model)

-- Test: do we see better model fit (correlation) by adding more alternatives?
```{r basic_rsa_plot}
# rsa.tuneDepthAlpha()
```

## Secondary analysis

-- Any particular domains are scalar families harder for RSA to fit? Why?
```{r}
# ggplot()
```
