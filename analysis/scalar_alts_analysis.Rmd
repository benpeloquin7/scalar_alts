---
title: "Scalar alternatives analysis"
author: "Ben Peloquin & Mike Frank"
date: "July 22, 2016"
output:
  html_document:
    toc: true
    toc_depth: 4
---

Packages
```{r packages, warning=FALSE, message=FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(rjson)
library(binom)
library(lme4)
source("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/useful_dplyr.R")
```


Experimental set-up notes

Note: this is not a part of pre-registration analysis
```{r expt_setup}
## Literal listener trials
NUM_ITEMS <- 105
trials <- sample.int(n=NUM_ITEMS, size=NUM_ITEMS)

trial_meta <- function(n) {
  item <- n %% 21
  stars <- n %% 5
  c("item"=item, "stars"=stars)
}

d_trials <- data.frame(t(as.matrix(sapply(trials, trial_meta))))
d_trials <- d_trials %>%
  mutate(stars=stars + 1) %>%
  arrange(item)
```

# Stimuli
```{r data_helpers}
## global data
NUM_ITEMS <- 21 ## number of individual target scalars (some are shared)
DOMAINS <- c("album", "book", "game", "play", "movie", "restaurant")
## scales
bad_terrible <-            c("terrible", "bad", "okay", "good", "great")
liked_loved <-             c("hated", "disliked", "tolerated", "liked", "loved")
good_excellent <-          c("terrible", "bad", "average", "good", "excellent")
memorable_unforgettable <- c("forgettable", "boring", "ordinary", "memorable", "unforgettable")
special_unique <-          c("boring", "different", "common", "special", "unique")

## valence
map_word_type <- function(word) {
  hi2 <- c("great", "loved", "excellent", "unforgettable", "unique")
  hi1 <- c("good", "liked", "memorable", "special")
  mid <- c("okay", "tolerated", "average", "ordinary", "common")
  low1 <- c("bad", "disliked", "bad", "boring", "different")
  low2 <- c("terrible", "hated", "terrible", "forgettable", "boring")
  
  if (word %in% hi2) "hi2"
  else if (word %in% hi1) "hi1"
  else if (word %in% mid) "mid"
  else if (word %in% low1) "low1"
  else if (word %in% low2) "low2"
  else "training"
}
```

Helpers
```{r}
## get_data_single_L0_file()
## -------------------------
## read in a single file from L0
##
get_data_single_L0_file <- function(file, domain=NA) {
  if (is.na(domain)) error("Must enter domain")
  d_raw <- fromJSON(file=file)
  d_answers <- data.frame(d_raw$answers)
  pattern <- "data\\."
  colnames(d_answers) <- sub(pattern, "", colnames(d_answers))
  d_answers <- d_answers %>%
    mutate(study="L0",
           language=as.character(language),
           domain=domain,
           item=as.character(item),
           age=as.numeric(as.character(age)),
           stars=as.numeric(as.character(stars))/20,
           judgment=as.numeric(judgment)-1,
           worker_id=d_raw$WorkerId)
  d_answers$word_type <- sapply(d_answers$item, map_word_type)
  d_answers <- d_answers %>%
    select(worker_id, study, domain, word_type, item, stars, judgment, age, gender, expt_aim, expt_gen, language)
  d_answers
}
```

# 1) Literal Listener (L0) analysis 

## Experimental set-up

Literal listener studies provide approximate literal semantic data for our target scalar items. 

We're testing 5 scales, each containing 5 items, across 6 domains (see `Stimuli` section above). Since some words are shared between scales we have 21 unique words. See `Stimuli` section above.

Data for domains is between subjects -- subjects only provide responses in the context of one domain at a time.

Data for individual words is within subjects -- subjects provide five ratings for each word (one judgment for each star rating 1-5 stars for a total of 5 * 21 = 105 responses for each participant).

Response is a binary `yes`/`no` response if the target word is compatible with the displayed star-rating.

<br>
<center>
  <br>
  <img src="/Users/benpeloquin/Desktop/Projects/scalar_alts/pre-registration/L0_design.png"
  width="500px" height="200px" style='border:1px solid #000000'>
  <br>
  <caption>Example trial from L0 Literal listener study.</caption>
  <br>
</center>
<br>

```{r data_processing_helpers}
## filter_df() 
## -----------
## filtered literal semantics df
##
filter_df <- function(d, verbose=TRUE) {
  bad_ids <- d %>%
    filter(word_type == "training") %>%
    group_by(worker_id) %>%
    summarise(training_perf=sum(judgment)) %>%
    filter(training_perf != 2) ## filter out anyone who doesn't pass both training trials or took the study mult times
  ## Filtered data
  d_filtered <- d %>%
    filter(!(worker_id %in% bad_ids$worker_id),
           word_type != "training")
  
  if (verbose) {
    num_participants <- 50
    warning(paste0(num_participants - length(unique(d_filtered$worker_id)),
                   " of ", num_participants, " filtered out."))
  }
  
  d_filtered
}
# head(filter_df(d_L0))

## create_domain_df() 
## ------------------
## create a single domain level df
##
create_domain_df <- function(domain=NA, dir_path=NA, filter=TRUE, verbose=TRUE) {
  if (is.na(domain) | is.na(dir_path)) error("Need to pass `domain` and `dir_path` args")
  
  ## Data hold
  d <- data.frame(worker_id=c(),
                   study=c(),
                   domain=c(),
                   word_type=c(),
                   item=c(),
                   stars=c(),
                   judgment=c(),
                   age=c(),
                   gender=c(),
                   expt_aim=c(),
                   expt_gen=c(),
                   language=c())
  dir_path <- paste0("/Users/benpeloquin/Desktop/Projects/scalar_alts/data/L0_data/", domain, "/")
  
  ## Add files
  files <- list.files(dir_path)
  if (verbose) warning(paste0("Currently reading in files for ", domain, "..."))
  for (file in files) {
    d <- rbind(d, get_data_single_L0_file(paste0(dir_path, file), domain))
  }
  
  ## Check for filtering
  if (filter) return_df <- filter_df(d, verbose=verbose)
  else return_df <- d
  
  return_df
}

## construct_dir_path()
## --------------------
## Construct path to data dir for literal listener or pragmatic listener judgments
##
create_dir_path <- function(domain, L0=TRUE) {
  if (L0) paste0("/Users/benpeloquin/Desktop/Projects/scalar_alts/data/L0_data/", domain, "/")
  else paste0("/Users/benpeloquin/Desktop/Projects/scalar_alts/data/L1_data/", domain, "/")
}
```

## Data pre-processing (combine domains, data-typing).
```{r L0_data_preprocessing}
# d_album <- create_domain_df("album", dir_path=create_dir_path("album"), filter=TRUE, verbose=TRUE)
d_book <- create_domain_df("book", dir_path=create_dir_path("book"), filter=TRUE, verbose=TRUE)
# d_game <- create_domain_df("game", dir_path=create_dir_path("game"), filter=TRUE, verbose=TRUE)
# d_movie <- create_domain_df("movie", dir_path=create_dir_path("movie"), filter=TRUE, verbose=TRUE)
# d_play <- create_domain_df("play", dir_path=create_dir_path("play"), filter=TRUE, verbose=TRUE)
d_restaurant <- create_domain_df("restaurant", dir_path=create_dir_path("restaurant"), filter=TRUE, verbose=TRUE)

d_agg <- rbind(d_restaurant, d_book)
```

Literal semantics plot
```{r L0_plot}
## Literal semantics
d_agg_sems <- d_agg %>%
  group_by(domain, item, word_type, stars) %>%
  summarise(avg_judgment=mean(judgment),
            ci_low=binom.confint(sum(judgment), length(judgment))$lower[3],
            ci_high=binom.confint(sum(judgment), length(judgment))$upper[3]) 
```

```{r plot_literal_semantics1}
ggplot(d_agg_sems, aes(x=stars, y=avg_judgment, col=domain)) +
  geom_line() +
  geom_errorbar(aes(ymax=ci_high, ymin=ci_low), width=0) +
  # geom_pointrange(aes(ymax=ci_high, ymin=ci_low)) +
  facet_wrap(~item)
```

```{r plot_literal_semantics2}
ggplot(d_agg_sems, aes(x=stars, y=avg_judgment, col=item)) +
  geom_line() +
  geom_errorbar(aes(ymax=ci_high, ymin=ci_low), width=0) +
  # geom_pointrange(aes(ymax=ci_high, ymin=ci_low)) +
  facet_grid(domain~word_type)
```


## Primary analysis - domain level differences

### Plots by scalar pairs and domains
```{r L0_domain_differences_plot}
# ggplot()
```

### Does domain predict response?

Statistical test: Logistic regression

Is `domain` a sigificant predictor of response.

Null hypothesis is there are no differences between domain (i.e. domain should not significantly predict response after controlling for `target_word`).
```{r L0_domain_differences_test}
d_agg <- d_agg %>%
  mutate(worker_id=as.factor(worker_id),
         item=as.factor(item))
summary(glm(judgment~item+domain, family="binomial", data=d_agg))
summary(glmer(judgment~domain+(1|item)+(1|worker_id), data=d_agg))
```

## Secondary analysis -- word level differences

### Plots by word and domains (line chart, facets by word, lines are literal semantics for each domain)
```{r L0_word_sensitivity_plot}
# ggplot()
```

### Statistical test

- Logistic regression on data subset for each word

H0: domain should not predict response.
```{r L0_word_sensitivity_test1}
# glm()
```

- Chi-square test of independence
```{r L0_word_sensitivity_test2}
# chisq.test()
```

# 2) Pragmatic Listener (L1) analysis 

## Experimental set-up

Pragmatic listener studies provide pragmatic interpretations for our target scalar items. 

We're testing 5 scales, each containing 5 items, across 6 domains (see `stimuli` section above). Since some words are shared between scales we have 21 unique words.

Data for domains is between subjects -- subjects only provide responses in the context of one domain at a time.

Data for individual words is within subjects -- subjects provide one rating for each word (providing 1 * 21 = 21 responses per particpant).

Response is a rating between 1-5 stars.

<br>
<center>
  <br>
  <img src="/Users/benpeloquin/Desktop/Projects/scalar_alts/pre-registration/L1_design.png"
  width="500px" height="200px" style='border:1px solid #000000'>
  <br>
  <caption>Example trial from L1 Pragmatic listener study.</caption>
  <br>
</center>
<br>


## Data pre-processing (combine domains, data-typing).
```{r L1_data_preprocessing}
# read.csv()
```

## Primary analysis -- domain level differences

### Plots by scalar pairs and domains
```{r L1_domain_differences_plot}
# ggplot()
```

### Does domain predict response?

Statistical test: Multiple regression

Is `domain` a sigificant predictor of response.

Null hypothesis is there are no differences between domain (i.e. domain should not significantly predict response).
```{r L1_domain_differences_test}
# glm()
```

## Secondary analysis -- word level differences

### Plots by word and domains (line chart, facets by word, lines are pragmatic judgments for each domain)
```{r L1_word_sensitivity_plot}
# ggplot()
```

### Statistical tests

Null hypothesis is scalar word pragmatic judgment distributions should not differ by domain.

- Multiple regression on data subset

Domain should not predict response when controlling for `target_word`
```{r L1_word_sensitivity_test1}
# glm()
```

We don't expect to see any statistical differences.
```{r L1_word_sensitivity_test2}
# chisq.test()
```


# 3) RSA comparison with human judgments

-- Using L0 literal semantics as input to RSA how well can we fit the L1 pragmatic listener judgments varying the alternative sets available to the model?

## Basic RSA

-- `depth=1`, `alpha=1` 2-alt vs 3-alt vs 4-alt vs 5-alt models

-- Standard theory predicts that listeners need only consider entailment alternatives in order to generate the implicature (2-alt model)

-- Test: do we see better model fit (correlation) by adding more alternatives and tuning hyper-parameters?
```{r basic_rsa_test}
# rsa.runDf_grouped()
```

## Tuned RSA

-- `depth=fit`, `alpha=fit` 2-alt vs 3-alt vs 4-alt vs 5-alt models

-- Standard theory predicts that listeners need only consider entailment alternatives in order to generate the implicature (2-alt model)

-- Test: do we see better model fit (correlation) by adding more alternatives?
```{r basic_rsa_plot}
# rsa.tuneDepthAlpha()
```

## Secondary analysis

-- Any particular domains are scalar families harder for RSA to fit? Why?
```{r}
# ggplot()
```