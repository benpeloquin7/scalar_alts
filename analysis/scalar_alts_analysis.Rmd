---
title: "Scalar alternatives analysis"
author: "Ben Peloquin & Mike Frank"
date: "July 22, 2016"
output:
  html_document:
    toc: true
    toc_depth: 4
---


```{r clean_session}
rm(list=ls())
```

Packages
```{r packages, warning=FALSE, message=FALSE}
library(purrr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(rjson)
library(binom)
library(lme4)
library(lmerTest)
library(rrrsa)
source("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/scalar_alts_analysis_helpers.R")
```


Experimental set-up notes

Note: this is not a part of pre-registration analysis
```{r expt_setup}
## Literal listener trials
NUM_ITEMS <- 105
trials <- sample.int(n=NUM_ITEMS, size=NUM_ITEMS)

trial_meta <- function(n) {
  item <- n %% 21
  stars <- n %% 5
  c("item"=item, "stars"=stars)
}

d_trials <- data.frame(t(as.matrix(sapply(trials, trial_meta))))
d_trials <- d_trials %>%
  mutate(stars=stars + 1) %>%
  arrange(item)
```

# Stimuli
```{r global_helpers}
## global data
NUM_ITEMS <- 21 ## number of individual target scalars (some are shared)
DOMAINS <- c("album", "book", "game", "play", "movie", "restaurant")
## scales
bad_terrible <-            c("terrible", "bad", "okay", "good", "great")
liked_loved <-             c("hated", "disliked", "tolerated", "liked", "loved")
good_excellent <-          c("terrible", "bad", "average", "good", "excellent")
memorable_unforgettable <- c("forgettable", "boring", "ordinary", "memorable", "unforgettable")
special_unique <-          c("boring", "different", "common", "special", "unique")
all_scales <- data.frame("bad_terrible"=bad_terrible,
                         "liked_loved"=liked_loved,
                         "good_excellent"=good_excellent,
                         "memorable_unforgettable"=memorable_unforgettable,
                         "special_unique"=special_unique)
weaker <- c("bad", "liked", "good", "memorable", "special")
stronger <- c("terrible", "loved", "excellent", "unforgettable", "unique")

## valence
map_word_type <- function(word) {
  hi2 <- c("great", "loved", "excellent", "unforgettable", "unique")
  hi1 <- c("good", "liked", "memorable", "special")
  mid <- c("okay", "tolerated", "average", "ordinary", "common")
  low1 <- c("bad", "disliked", "bad", "forgettable", "different")
  low2 <- c("terrible", "hated", "terrible", "boring", "boring")
  
  if (word %in% hi2) "hi2"
  else if (word %in% hi1) "hi1"
  else if (word %in% mid) "mid"
  else if (word %in% low1) "low1"
  else if (word %in% low2) "low2"
  else "training"
}
```

# 1) Literal Listener (L0) analysis 

## Experimental set-up

Literal listener studies provide approximate literal semantic data for our target scalar items. 

We're testing 5 scales, each containing 5 items, across 6 domains (see `Stimuli` section above). Since some words are shared between scales we have 21 unique words. See `Stimuli` section above.

Data for domains is between subjects -- subjects only provide responses in the context of one domain at a time.

Data for individual words is within subjects -- subjects provide five ratings for each word (one judgment for each star rating 1-5 stars for a total of 5 * 21 = 105 responses for each participant).

Response is a binary `yes`/`no` response if the target word is compatible with the displayed star-rating.

<br>
<center>
  <br>
  <img src="/Users/benpeloquin/Desktop/Projects/scalar_alts/pre-registration/L0_design.png"
  width="500px" height="200px" style='border:1px solid #000000'>
  <br>
  <caption>Example trial from L0 Literal listener study.</caption>
  <br>
</center>
<br>

## Data pre-processing (combine domains, data-typing).
```{r L0_data_preprocessing, warning=FALSE, message=FALSE}
d_album_L0 <- create_domain_df("album", dir_path=create_dir_path("album", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_book_L0 <- create_domain_df("book", dir_path=create_dir_path("book", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_game_L0 <- create_domain_df("game", dir_path=create_dir_path("game", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_movie_L0 <- create_domain_df("movie", dir_path=create_dir_path("movie", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_play_L0 <- create_domain_df("play", dir_path=create_dir_path("play", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)
d_restaurant_L0 <- create_domain_df("restaurant",
                                 dir_path=create_dir_path("restaurant", "L0"), study_type="L0", filter=TRUE, verbose=TRUE)

d_agg_L0 <- rbind(d_album_L0, d_book_L0, d_game_L0, d_movie_L0, d_play_L0, d_restaurant_L0)
```

Non-normalized literal semantics with CI intervals
```{r L0_data_prep, warning=FALSE, message=FALSE}
## Literal semantics
d_agg_sems <- d_agg_L0 %>%
  group_by(domain, item, word_type, stars) %>%
  summarise(avg_judgment=mean(judgment),
            ci_low=binom.confint(sum(judgment), length(judgment))$lower[3],
            ci_high=binom.confint(sum(judgment), length(judgment))$upper[3]) %>%
  ungroup %>%
  mutate(domain=as.factor(domain))
```

## Primary analysis - domain level differences

### Plots by scalar pairs and domains

Plot non-normalized literal listener semantics, facet by word, color by domain.
```{r L0_domain_differences_plot}
ggplot(d_agg_sems, aes(x=stars, y=avg_judgment, col=domain)) +
  geom_line() +
  geom_errorbar(aes(ymax=ci_high, ymin=ci_low), width=0) +
  facet_wrap(~item)
```

Plot non-normalized literal listener semantics, facet by scale and word-valence, color by word.
```{r L0_domain_differences_plot2, eval=FALSE}
ggplot(d_agg_sems, aes(x=stars, y=avg_judgment, col=item)) +
  geom_line() +
  geom_errorbar(aes(ymax=ci_high, ymin=ci_low), width=0) +
  facet_grid(domain~word_type)
```

Doesn't look like there's much differentiation in literal semantics by domain.

### Does domain predict response?

Statistical test: Logistic regression

Is `domain` a sigificant predictor of response.

Null hypothesis is there are no differences between domain (i.e. domain should not significantly predict response after controlling for `target_word`).
```{r L0_domain_differences_test}
## L0 listener data for glmer and glm
d_agg_L0_test <- d_agg_L0 %>%
  mutate(worker_id=as.factor(worker_id),
         study=as.factor(study),
         domain=as.factor(domain),
         word_type=as.factor(word_type),
         item=as.character(item))
# knitr::kable(summary(glm(judgment~item+domain+word_type, family="binomial", data=d_agg_L0_test)))
## Having convergence issues with glmer
# summary(glmer(judgment ~ item + (1|worker_id), family="binomial", data=d_agg_L0_test))
knitr::kable(summary(glm(judgment ~ item*domain + stars, family="binomial", data=d_agg_L0_test))$coef)
```

I'm having convergence issues with `glmer()` so I'm sticking with multiple logistic regression. We're including the interaction term `item*domain` here. I'm not seeing signs of significant differences between indiviual words and domains from this summary.

## Secondary analysis -- word level differences

### Plots by word and domains (line chart, facets by word, lines are literal semantics for each domain)
```{r L0_word_sensitivity_plot}
# ggplot()
```

### Statistical test

- Logistic regression on data subset for each word

H0: domain should not predict response.
```{r L0_word_sensitivity_test1}
# glm()
```

- Chi-square test of independence
```{r L0_word_sensitivity_test2}
# chisq.test()
```

# 2) Pragmatic Listener (L1) analysis 

## Experimental set-up

Pragmatic listener studies provide pragmatic interpretations for our target scalar items. 

We're testing 5 scales, each containing 5 items, across 6 domains (see `stimuli` section above). Since some words are shared between scales we have 21 unique words.

Data for domains is between subjects -- subjects only provide responses in the context of one domain at a time.

Data for individual words is within subjects -- subjects provide one rating for each word (providing 1 * 21 = 21 responses per particpant).

Response is a rating between 1-5 stars.

<br>
<center>
  <br>
  <img src="/Users/benpeloquin/Desktop/Projects/scalar_alts/pre-registration/L1_design.png"
  width="500px" height="200px" style='border:1px solid #000000'>
  <br>
  <caption>Example trial from L1 Pragmatic listener study.</caption>
  <br>
</center>
<br>


## Data pre-processing (combine domains, data-typing).
```{r L1_data_preprocessing, warning=FALSE, message=FALSE}
d_album_L1 <- create_domain_df("album", dir_path=create_dir_path("album", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_book_L1 <- create_domain_df("book", dir_path=create_dir_path("book", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_game_L1 <- create_domain_df("game", dir_path=create_dir_path("game", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_movie_L1 <- create_domain_df("movie", dir_path=create_dir_path("movie", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_play_L1 <- create_domain_df("play", dir_path=create_dir_path("play", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)
d_restaurant_L1 <- create_domain_df("restaurant",
                                 dir_path=create_dir_path("restaurant", "L1"), study_type="L1", filter=TRUE, verbose=TRUE)

d_agg_L1 <- rbind(d_album_L1, d_book_L1, d_game_L1, d_movie_L1, d_play_L1, d_restaurant_L1)
```

Pragmatic judgment counts
```{r L1_data_prep}
d_agg_prags <-  d_agg_L1 %>%
  group_by(domain, word_type, item, judgment) %>%
  summarise(counts=n()) %>%
  ungroup %>%
  group_by(domain, item) %>%
  mutate(total_item_counts=sum(counts)) %>%
  rowwise %>%
  mutate(proportion_counts=counts/total_item_counts)
```

Average ragins -- bootstrap CI's here...
```{r}
d_agg_prags %>%
  mutate(judgment_times_counts=judgment*counts) %>%
  group_by(domain, item, total_item_counts) %>%
  summarise(total_weighted_counts=sum(judgment_times_counts)) %>%
  mutate(avg_rating=total_weighted_counts/total_item_counts) %>%
  ggplot(aes(x=domain, y=avg_rating)) +
    geom_point() +
    # geom_bar(stat="identity", position="dodge") +
    facet_wrap(~item) +
    theme_bw()
```


## Primary analysis -- domain level differences

### Plots by scalar pairs and domains

```{r L1_domain_differences_plot}
ggplot(d_agg_prags, aes(x=judgment, y=proportion_counts, fill=domain)) +
    geom_bar(position="dodge", stat="identity") +
    facet_wrap(~item)
```

```{r}
ggplot(d_agg_prags, aes(x=judgment, y=proportion_counts, fill=item)) +
    geom_bar(position="dodge", stat="identity") +
    facet_grid(domain~word_type)
```


### Does domain predict response?

Statistical test: Multiple regression

Is `domain` a sigificant predictor of response.

Null hypothesis is there are no differences between domain (i.e. domain should not significantly predict response).
```{r L1_domain_differences_test}
knitr::kable(summary(lmer(judgment~domain + (1|item) + (1|worker_id), data=d_agg_L1))$coef)
knitr::kable(summary(lmer(judgment~domain*item + (1|worker_id), data=d_agg_L1))$coef)
```

## Secondary analysis -- word level differences

### Plots by word and domains (line chart, facets by word, lines are pragmatic judgments for each domain)
```{r L1_word_sensitivity_plot}
# ggplot()
```

### Statistical tests

Null hypothesis is scalar word pragmatic judgment distributions should not differ by domain.

- Multiple regression on data subset

Domain should not predict response when controlling for `target_word`
```{r L1_word_sensitivity_test1}
# glm()
```

We don't expect to see any statistical differences.
```{r L1_word_sensitivity_test2}
# chisq.test()
```


# 3) RSA comparison with human judgments

## RSA helpers

Combine L0 and L1 data. Prepare for use with `rrrsa`.
```{r rsa_read_df}

## rsa_read_df()
## ------------
## Write a data frame that is read to run through rsa.runDf
##
rsa_read_df <- function(d_L0, d_L1) {
  
  ## Normalize L0
  normalize_semantics <- function(d) {
    norm_vec(d$avg_judgment)
  }
  pattern <- "V([1-5])"
  d_L0_sems <- plyr::ddply(.data=d_L0, .variables=c("domain", "word_type", "item"), .fun=normalize_semantics) %>%
    gather(stars, sems, -c(domain, word_type, item)) %>%
    arrange(domain, item, stars, word_type) %>%
    rowwise %>%
    mutate(stars=as.numeric(gsub(pattern, "\\1", stars)))
  
  ## Combine L0 and L1 data
  d_agg_L0_merge <- d_L0_sems
  d_agg_L1_merge <- d_L1 %>%
    mutate(stars=judgment) %>%
    select(domain, word_type, item, stars, counts)

  ## Joined data (L1 not normalized)
  d_agg_join <- plyr::join(d_agg_L0_merge, d_agg_L1_merge, by=c("domain", "word_type", "item", "stars"))
  d_agg_join[is.na(d_agg_join)] <- 0
  
  ## Normalize L1
  normalize_pragmatics <- function(d) {
    norm_vec(d$counts)
  }
  pattern <- "V([1-5])"
  normed_prags <- plyr::ddply(.data=d_agg_join, .variables=c("domain", "word_type", "item"), .fun=normalize_pragmatics) %>%
    gather(key=stars, value=prags, c(V1, V2, V3, V4, V5)) %>%
    rowwise %>%
    mutate(stars=as.numeric(gsub(pattern, "\\1", stars))) %>%
    arrange(domain, item, stars)
  
  ## Combined normalized semantics and pragmatics df
  d_agg_final <- plyr::join(d_agg_join, normed_prags, by=c("domain", "word_type", "item", "stars"))
  
  ## Data in wide format
  sems_wide <- d_agg_final %>% select(domain, word_type, item, stars, sems) %>%
    spread(stars, sems)
  prags_wide <- d_agg_final %>% select(domain, word_type, item, stars, prags) %>%
    spread(stars, prags)
  
  ## Data holds for separate semantics and pragmatics
  sems_scales_df <- data.frame(domain=c(),
                            item=c(),
                            scale=c(),
                            "1"=c(),
                            "2"=c(),
                            "3"=c(),
                            "4"=c(),
                            "5"=c())
  prags_scales_df <- data.frame(domain=c(),
                            item=c(),
                            scale=c(),
                            "1"=c(),
                            "2"=c(),
                            "3"=c(),
                            "4"=c(),
                            "5"=c())
  ## Populate data holds
  for (domain in DOMAINS) {
    for (scale in names(all_scales)) {
      for (item in all_scales[[scale]]) {
        # print("item:")
        # print(item)
        # print("----------------------")
        curr_sems_row <- sems_wide[which(sems_wide$item==item & sems_wide$domain==domain),] %>%
          mutate(scale=scale)
        curr_prags_row <- prags_wide[which(prags_wide$item==item & prags_wide$domain==domain),] %>%
          mutate(scale=scale)
        sems_scales_df <- rbind(sems_scales_df, curr_sems_row)
        prags_scales_df <- rbind(prags_scales_df, curr_prags_row)
      }
    }
  }
  sems_scales_df <- sems_scales_df %>%
    arrange(domain, scale, word_type, item) %>%
    gather(stars, sems, -c(domain, scale, word_type, item))
  prags_scales_df <- prags_scales_df %>%
    arrange(domain, scale, word_type, item) %>%
    gather(stars, prags, -c(domain, scale, word_type, item))
  
  ## Quick check
  nrow(sems_scales_df) == nrow(prags_scales_df)
  
  sems_scales_df[1:10,]
  prags_scales_df[1:10,]
  
  d_rsa_df <- dplyr::full_join(sems_scales_df, prags_scales_df)
  
  d_rsa_df
}

```

Get model indices
```{r get_compare_indices}
## get_compare_indices()
## ----------------------
## map word valence labels by model type
##
get_compare_indices <- function(d, model=NA) {
  
  if (model=="2") {
    indices <- which((d$scale=="bad_terrible" &
                        (d$word_type=="low1" |  d$word_type=="low2")) |
                       (d$scale!="bad_terrible" &
                          (d$word_type=="hi1" |  d$word_type=="hi2")))
  } else if (model=="3") {
    indices <- which((d$scale=="bad_terrible" &
                        (d$word_type=="low1" |  d$word_type=="low2" | d$word_type=="hi1")) |
                       (d$scale!="bad_terrible" &
                          (d$word_type=="hi1" |  d$word_type=="hi2" | d$word_type=="low1")))
  } else if (model=="4") {
    indices <- which((d$scale=="bad_terrible" &
                        (d$word_type=="low1" |  d$word_type=="low2" | d$word_type=="hi1" | d$word_type=="hi2")) |
                       (d$scale!="bad_terrible" &
                          (d$word_type=="hi1" |  d$word_type=="hi2" | d$word_type=="low1" | d$word_type=="low2")))
    
  } else if (model=="5") {
    indices <- seq(nrow(d))
  } else error("Please specify model; one of '2', '3', '4', or '5'")
  
  indices
}
```

Combined df with sems and prags
```{r combine_sems_prags}
d_joined_m <- rsa_read_df(d_agg_sems, d_agg_prags)
```

Individual models
```{r create_model_dfs, warning=FALSE, message=FALSE}
two_alt_m <- d_joined_m[get_compare_indices(d_joined_m, model="2"), ]
three_alt_m <- d_joined_m[get_compare_indices(d_joined_m, model="3"), ]
four_alt_m <- d_joined_m[get_compare_indices(d_joined_m, model="4"), ]
five_alt_m <- d_joined_m[get_compare_indices(d_joined_m, model="5"), ]
```

-- Using L0 literal semantics as input to RSA how well can we fit the L1 pragmatic listener judgments varying the alternative sets available to the model?

## Basic RSA

### Experiment 1: Tune depth alpha for each model aggregating over `scale` and `domain`

Tune models aggregating over `domain`
```{r tuning_helpers}
ALPHAS <- seq(0, 6, by=0.1)
DEPTHS <- seq(0, 4)
MODELS <- as.character(seq(2, 5))

plot_tuning_curves <- function(d) {
  ggplot(d, aes(x=alpha, y=r, col=as.factor(depth))) +
    geom_line()
}
```

```{r}
## tune_alpha_depth()
## ------------
## tune alphas for model against taregt indices
##
tune_alpha_depth_over_domain_scale <- function(d_model,
                             alphas=seq(1, 4, by=0.1),
                             depths=seq(1,3)) {
  
  cors <- data.frame(r=c(), alpha=c(), depth=c())
  for (alpha in alphas) {
    for (depth in depths) {
      
      ## Run on each alpha/depth
      out <- d_model %>%
        split(list(.$domain, .$scale)) %>%
        map_df(~rsa.runDf(
          data=.x,
          quantityVarName="stars",
          semanticsVarName="sems",
          itemVarName="item",
          depth=depth,
          alpha=alpha))
      
      tune_indices <- get_compare_indices(out, model="2")
      out_check <- out[tune_indices,]
      curr_cor <- cor(out_check$preds, out_check$prags)
      cors <- rbind(cors, data.frame(r=curr_cor, alpha=alpha, depth=depth)) 
    }
  }
  cors
}
```
Reproduce original tests (assume one level of recursion and tune alpha)

```{r exp1_load_cache}
m_test1 <- read.csv("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/m_test1.csv")
```

M2
```{r exp1_m2}
if (!("m_test1" %in% ls(envir=.GlobalEnv))) {
  two_alt_res <- tune_alpha_depth_over_domain_scale(two_alt_m, alphas=ALPHAS, depths=1)
  best_two_alpha <- two_alt_res[which.max(two_alt_res$r), ]
  plot_tuning_curves(two_alt_res)
}
```

M3
```{r exp1_m3}
if (!("m_test1" %in% ls(envir=.GlobalEnv))) {
  three_alt_res <- tune_alpha_depth_over_domain_scale(three_alt_m, alphas=ALPHAS, depths=1)
  best_three_alpha <- three_alt_res[which.max(three_alt_res$r), ]
  plot_tuning_curves(three_alt_res)
}
```

M4
```{r exp1_m4}
if (!("m_test1" %in% ls(envir=.GlobalEnv))) {
  four_alt_res <- tune_alpha_depth_over_domain_scale(four_alt_m, alphas=ALPHAS, depths=1)
  best_four_alpha <- four_alt_res[which.max(four_alt_res$r), ]
  plot_tuning_curves(four_alt_res)
}
```

M5
```{r exp1_m5}
if (!("m_test1" %in% ls(envir=.GlobalEnv))) {
  five_alt_res <- tune_alpha_depth_over_domain_scale(five_alt_m, alphas=ALPHAS, depths=1)
  best_five_alpha <- five_alt_res[which.max(five_alt_res$r), ]
  plot_tuning_curves(five_alt_res)
}
```

Compare tuning curves
```{r}
curves <- read.csv("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/curves.csv")
if (!("curves" %in% ls(envir=.GlobalEnv))) {
  curves <- rbind(two_alt_res %>% mutate(model="2"),
                 three_alt_res %>% mutate(model="3"),
                 four_alt_res %>% mutate(model="4"),
                 five_alt_res %>% mutate(model="5"))
  write.csv(curves, "/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/curves.csv")
}
curves %>%
  ggplot(aes(x=alpha, y=r, col=as.character(model))) +
    geom_line()
```
With a single recursion (depth=1) and tuning `alpha` we see substantial improvement in model fit with the inclusion of more alts. Note that our best correlation in each case is a bit lower than in our first study. In this case we are aggregating over domain, however.

```{r agg_over_scale_domain_res, eval=FALSE}
if (!("m_test1" %in% ls(envir=.GlobalEnv))) {
  m_test1 <- rbind(best_two_alpha %>% mutate(model="2"),
                   best_three_alpha %>% mutate(model="3"),
                   best_four_alpha %>% mutate(model="4"),
                   best_five_alpha %>% mutate(model="5"))
  write.csv(m_test1, "/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/m_test1.csv")
}
m_test1 %>%
  group_by(model) %>%
  summarise(num_run_recurse=sum(best_depth > 0),
            avg_r_delta=mean(best_r-L0_r)) %>%
  knitr::kable()

ggplot(m_test1, aes(x=model, y=r)) +
  geom_bar(stat="identity", position="dodge") +
  ggtitle("Highest model correlation\nwith tuned alpha and depth=1")
```
In this case we see substantial improvment in model fit when we include a negative valence alt...

Now tune both depth an alpha aggregating over scale and domain
```{r exp1a_, eval=FALSE}
two_alt_res <- tune_alpha_depth_over_domain_scale(two_alt_m, alphas=ALPHAS, depths=DEPTHS)
three_alt_res <- tune_alpha_depth_over_domain_scale(three_alt_m, alphas=ALPHAS, depths=DEPTHS)
four_alt_res <- tune_alpha_depth_over_domain_scale(four_alt_m, alphas=ALPHAS, depths=DEPTHS)
five_alt_res <- tune_alpha_depth_over_domain_scale(five_alt_m, alphas=ALPHAS, depths=DEPTHS)
rbind(two_alt_res %>% mutate(model="2"),
          three_alt_res %>% mutate(model="3"),
          four_alt_res %>% mutate(model="4"),
          five_alt_res %>% mutate(model="5")) %>%
  group_by(model) %>%
  summarise(best_r=max(r),
            best_alpha=alpha[which.max(r)],
            best_depth=depth[which.max(r)]) %>%
  knitr::kable()
```
This is interesting -- aggregating over scale and domain, our 2-, 3- and 4-alt listeners would be more effective by avoiding inference and simply considering the literal semantics. Only once we get to 5-alts does RSA provide any benefits.

### Experiment 2: Tune depth alpha for each `model` and `scale` aggregating over `domain`

Check for cached data...
```{r exp2_load_cache}
m_test2 <- read.csv("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/m_test2.csv")
```

```{r exp_2_helper}
tune_alpha_depth_over_domain <- function(d_model,
                                         alphas=seq(1, 4, by=0.1),
                                         depths=seq(1,3)) {
  
  cors <- data.frame(r=c(), scale=c(), alpha=c(), depth=c())
  for (curr_scale in names(all_scales)) {
    for (alpha in alphas) {
      for (depth in depths) {
        ## Run on each alpha/depth
        out <- d_model %>%
          filter(scale==curr_scale) %>%
          split(list(.$domain)) %>%
          map_df(~rsa.runDf(
            data=.x,
            quantityVarName="stars",
            semanticsVarName="sems",
            itemVarName="item",
            depth=depth,
            alpha=alpha))
        
        tune_indices <- get_compare_indices(out, model="2")
        out_check <- out[tune_indices,]
        curr_cor <- cor(out_check$preds, out_check$prags)
        cors <- rbind(cors, data.frame(r=curr_cor, scale=curr_scale, alpha=alpha, depth=depth)) 
      }
    }
  }
  
  cors
}
```

M2
```{r exp_2_m2}
if (!("m_test2" %in% ls(envir=.GlobalEnv))) {
  two_alt_res <- tune_alpha_depth_over_domain(two_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_2 <- two_alt_res %>%
    group_by(scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)]) %>%
    mutate(r_delta=best_r-L0_r)
}
```

M3
```{r exp_2_m3}
if (!("m_test2" %in% ls(envir=.GlobalEnv))) {
  three_alt_res <- tune_alpha_depth_over_domain(three_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_3 <- three_alt_res %>%
    group_by(scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)]) %>%
    mutate(r_delta=best_r-L0_r)
}
```

M4
```{r exp_2_m4}
if (!("m_test2" %in% ls(envir=.GlobalEnv))) {
  four_alt_res <- tune_alpha_depth_over_domain(four_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_4 <- four_alt_res %>%
    group_by(scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)]) %>%
    mutate(r_delta=best_r-L0_r)
}
```

M5
```{r exp_2_m5}
if (!("m_test2" %in% ls(envir=.GlobalEnv))) {
  five_alt_res <- tune_alpha_depth_over_domain(five_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_5 <- five_alt_res %>%
    group_by(scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)]) %>%
    mutate(r_delta=best_r-L0_r)
}
```

Taking a look at tuning together...
```{r exp_2_combined}
if (!("m_test2" %in% ls(envir=.GlobalEnv))) {
  m_test2 <- rbind(best_2 %>% mutate(model="2"),
                 best_3 %>% mutate(model="3"),
                 best_4 %>% mutate(model="4"),
                 best_5 %>% mutate(model="5"))
  write.csv(m_test2, "/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/m_test2.csv")
}

m_test2 %>%
  group_by(model) %>%
  summarise(num_run_recurse=sum(best_depth > 0),
            avg_r_delta=mean(best_r-L0_r)) %>%
  knitr::kable()
# ggplot(m_test2, aes(x=scale, y=best_r, fill=model)) +
#   geom_bar(stat="identity", position="dodge") +
#   theme(axis.text.x=element_text(angle=45, hjust=1))
```
Interesting, again looks like the benefits inference really only begins when there is a full set of alternatives.

### Experiment 3: Tune depth alpha for each `model`, `scale` and `domain`
```{r exp3_helpers}
tune_alpha_depth <- function(d_model,
                             alphas=seq(1, 4, by=0.1),
                             depths=seq(1,3)) {
  
  cors <- data.frame(r=c(), scale=c(), domain=c(), alpha=c(), depth=c())

  for (curr_domain in DOMAINS) {
    for (curr_scale in names(all_scales)) {
      for (alpha in alphas) {
        for (depth in depths) {
          ## Run on each alpha/depth
          curr_d <- d_model %>%
            filter(scale==curr_scale, domain==curr_domain)
          ## No need to use map_df here
          out <- rsa.runDf(data=curr_d,
                    quantityVarName="stars",
                    semanticsVarName="sems",
                    itemVarName="item",
                    depth=depth,
                    alpha=alpha)
          tune_indices <- get_compare_indices(out, model="2")
          out_check <- out[tune_indices,]
          ## Check if RSA predicts uniform probability across responses (then correlation is 0)
          curr_cor <- ifelse(sd(out_check$preds) != 0, cor(out_check$preds, out_check$prags), 0)
          cors <- rbind(cors, data.frame(r=curr_cor, scale=curr_scale, domain=curr_domain, alpha=alpha, depth=depth)) 
        }
      }
    }
  }
  cors
}
```

When there are no 0 value semantics (a word eg "memorable" is compatible at every star-rating then rsa returns uniform probability)

Check for cached data...
```{r exp3_load_cache}
m_test3 <- read.csv("/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/m_test3.csv")
```


M2
```{r exp3_m2}
if (!("m_test3" %in% ls(envir = .GlobalEnv))) {
  two_alt_res <- tune_alpha_depth(two_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_2 <- two_alt_res %>%
    group_by(domain, scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(domain, scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)]) 
}
```

M3
```{r exp3_m3}
if (!("m_test3" %in% ls(envir = .GlobalEnv))) {
  three_alt_res <- tune_alpha_depth(three_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_3 <- three_alt_res %>%
    group_by(domain, scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(domain, scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)])
  
}
```

M4
```{r exp3_m4}
if (!("m_test3" %in% ls(envir = .GlobalEnv))) {
  four_alt_res <- tune_alpha_depth(four_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_4 <- four_alt_res %>%
    group_by(domain, scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(domain, scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)])
}
```

M5
```{r exp3_m5}
if (!("m_test3" %in% ls(envir = .GlobalEnv))) {
  five_alt_res <- tune_alpha_depth(five_alt_m, alphas=ALPHAS, depths=DEPTHS)
  best_5 <- five_alt_res %>%
    group_by(domain, scale) %>%
    mutate(L0_r=r[which(depth==0 & alpha==0)]) %>%
    group_by(domain, scale, L0_r) %>%
    summarise(best_r=max(r),
              best_alpha=alpha[which.max(r)],
              best_depth=depth[which.max(r)])
}
```

Combine results
```{r eval=FALSE}
if (!("m_test3" %in% ls(envir = .GlobalEnv))) {
  m_test3 <- rbind(best_2 %>% mutate(model="2"),
                   best_3 %>% mutate(model="3"),
                   best_4 %>% mutate(model="4"),
                   best_5 %>% mutate(model="5"))
  write.csv(m_test3, "/Users/benpeloquin/Desktop/Projects/scalar_alts/analysis/cache/m_test3.csv")
}

m_test3 %>%
  group_by(model) %>%
  summarise(num_run_recurse=sum(best_depth > 0),
            num_comparisons=n(),
            avg_r_delta=mean(best_r-L0_r)) %>%
  knitr::kable()
```

RSA runs with best parameter settings
```{r m3_performance_data}
d_best_models <- data.frame(domain=c(),
                            word_type=c(),
                            item=c(),
                            scale=c(),
                            stars=c(),
                            sems=c(),
                            prags=c(),
                            preds=c(),
                            alpha=c(),
                            depth=c(),
                            model=c())
  
for (i in 1:nrow(m_test3)) {
  curr_domain <- m_test3[i, ]$domain
  curr_scale <- m_test3[i, ]$scale
  curr_alpha <- m_test3[i, ]$best_alpha
  curr_depth <- m_test3[i, ]$best_depth
  curr_model_num <- m_test3[i, ]$model
  
  curr_d <- d_joined_m %>%
    filter(domain==curr_domain,
           scale==curr_scale)
  curr_model_indices <- get_compare_indices(curr_d, as.character(curr_model_num))
  curr_model_d <- curr_d[curr_model_indices, ]

  curr_out <- rsa.runDf(curr_model_d,
                        quantityVarName="stars",
                        semanticsVarName="sems",
                        itemVarName="item",
                        alpha=curr_alpha,
                        depth=curr_depth) %>%
    mutate(alpha=curr_alpha,
           depth=curr_depth,
           model=curr_model_num)
  
  d_best_models <- rbind(d_best_models, curr_out)
}
```

Best model fit scatter plots
```{r best_model_scatterplot}
compare_indices <- get_compare_indices(d_best_models, model="2")
d_best_models[compare_indices, ] %>%
  ggplot(aes(x=preds, y=prags)) +
    xlab("Model Predictions") +
    ylab("Proportion choosing target") +
    geom_point(alpha=0.85, aes(col=item, shape=domain)) +
    geom_smooth(method="lm", aes(group=1)) +
    facet_grid(model~scale) +
    geom_abline(slope = 1, intercept = 0, lty=2, "gray") + 
    theme_bw()
```

This plot is really too hard to read... Take away is that at 5 alternatives RSA pushes most of the weaker terms to 1 or 0.
```{r best_model_line_plot, eval=FALSE}
d_best_models[compare_indices, ] %>%
  gather(type, value, c(prags, preds)) %>%
  ggplot(aes(x=as.numeric(stars), y=value, lty=type, col=word_type)) +
    geom_line() +
    xlab("Stars") +
    ylab("Proportion choosing target /\n Model predictions") +
    facet_grid(model~scale+domain) +
    theme_bw()
```

Which models move furthest away from literal semantics?
```{r best_models_summary1}
d_best_models[compare_indices,] %>%
  group_by(model) %>%
  summarise(avg_num_recurse=mean(depth),
            avg_alpha=mean(alpha),
            avg_r=cor(preds, prags)) %>%
  knitr::kable()
```

Scale specific `domain`
```{r best_models_summary2}
d_best_models[compare_indices,] %>%
  group_by(model, scale) %>%
  summarise(avg_num_recurse=mean(depth),
            avg_alpha=mean(alpha),
            avg_r=cor(preds, prags)) %>%
  arrange(scale, model) %>%
  knitr::kable()
```

## Tuned RSA

-- `depth=fit`, `alpha=fit` 2-alt vs 3-alt vs 4-alt vs 5-alt models

-- Standard theory predicts that listeners need only consider entailment alternatives in order to generate the implicature (2-alt model)

-- Test: do we see better model fit (correlation) by adding more alternatives?
```{r basic_rsa_plot}
# rsa.tuneDepthAlpha()
```

## Secondary analysis

-- Any particular domains are scalar families harder for RSA to fit? Why?
```{r}
# ggplot()
```